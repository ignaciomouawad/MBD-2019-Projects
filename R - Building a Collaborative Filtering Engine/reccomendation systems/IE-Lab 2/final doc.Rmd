---
title: "Recommendation Engines Quora"
author: "Benjamin Chumaceiro | Ignacio Mouawad | Maria Joyce | Rosalia Contreras Moreira | Eduardo Cort Pons | Srishti Singh
date: "10/12/2019"
output:
  word_document: default
  pdf_document: default
---
##Downloading Data, Libraries and cleaning the data.
The excel Lab sheet was divided int 3 segments that returned 3 CSV files: question topics, user feedback and User Answers. Then we clean the data given
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(lsa)
question_topics <- read.csv("questiontopics.csv")
feedback <- read.csv("userfeedback.csv")
answers <- read.csv("useranswers.csv")

answers<-answers[1:4]
feedback<-feedback[1:4]
rownames(question_topics) <- question_topics$X

question_topics$X<-NULL
rownames(answers)<-rownames(question_topics)
rownames(feedback)<- rownames(question_topics)

question_answer <- sort(rowMeans(answers, na.rm = T), decreasing = T)
question_answer
question_feedback <- mean_ratings <- sort(rowMeans(feedback, na.rm = T), decreasing = T)
question_feedback

```

## Simple Unary
**Given a set of users and questions, infer the users profile considering how many questions with its associated topics the user likes/dislikes. Use a dot product. Each user would end with a numeric value for each topic. With the user profiles, predict each user
probability to like/dislike each question and count the total number of likes, dislikes and neutral predictions. To finalise, with the predictions provide the top-5 questions recommended per each user.**

Simple Unary recommendation engines are not normalised by number of votes/rates present in an item and also all keywords are considered equally significant.

### User Profile
To calculate the user profile we calculated the sum of the products between the topics of each question and the user feedback.
```{r}
simple_unary_user_profile <- data.frame()
for(k in 1:ncol(feedback)){
  j<- vector()
  for(i in 1:ncol(question_topics)){
    j[i]<- sum(question_topics[,i]*feedback[,k], na.rm = T)
  }
  simple_unary_user_profile<-rbind(simple_unary_user_profile,j)

}

colnames(simple_unary_user_profile)<-colnames(question_topics)
rownames(simple_unary_user_profile) <- colnames(feedback)
simple_unary_user_profile
```
### Calculating Predictions
The predictions for the Simple Unary are calculated as follows, by using the Cosine function on the topic profile and the user profile created in the step above:

```{r calculating predictions }
unary_predict_table <- data.frame()

for(i in 1:nrow(simple_unary_user_profile)){
  for(k in 1:nrow(question_topics)){
    unary_predict_table[k,i]<-  cosine(as.numeric(question_topics[k,]),as.numeric(simple_unary_user_profile[i,]))
  
  }
}
colnames(unary_predict_table) <- rownames(simple_unary_user_profile)
unary_predict_table[,"User.4"] <- 0
unary_predict_table

```

### Likes tables 
Calculating likes, dislike and neutrals. When the prediction is bigger than 0 it is considered a like, when lower than 0, a dislike and when it is 0, it is considered to be neutral.
```{r}

likes_dislikes <- rbind(sapply(unary_predict_table, function(x){sum(x>0)}))
likes_dislikes <- rbind(likes_dislikes,sapply(unary_predict_table, function(x){sum(x<0)}))
likes_dislikes <- rbind(likes_dislikes,sapply(unary_predict_table, function(x){sum(x==0)}))
rownames(likes_dislikes) <- c("likes", "dislikes","neutral")
likes_dislikes
```

## Unit Weight
**Some questions have more influence in the result as contain more topics. Normalise the topics frequency for each question and calculate the predictions again. Divide the keywords (topics) appearance by the total number of keywords that the question has. With the new predictions, provide the top-5 questions recommended per each user.**

Unit Weight recomendation engines are normalised by number of votes/rates present in an item and also all keywords are considered equally significant.

### User Profile
To calculate the user profile it is first required to normalize the question topics by adding weight to them. We divide each question topic by the sum of all topics a question can have. Then we calculated the sum of the products between the topics normalized for each question and the user feedback.
```{r}
CB_unit_weight <- data.frame()

for(k in 1:nrow(question_topics)){
  for(i in 1:ncol(question_topics)){
    CB_unit_weight[k,i] <- question_topics[k,i]/sum(question_topics[k,]) 
  }
}

unit_weight_user_profile <- data.frame()
for(k in 1:ncol(feedback)){
  j<- vector()
  for(i in 1:ncol(CB_unit_weight)){
    j[i]<- sum(CB_unit_weight[,i]*feedback[,k], na.rm = T)
  }
  unit_weight_user_profile<-rbind(unit_weight_user_profile,j)
  
}

colnames(unit_weight_user_profile)<-colnames(question_topics)
rownames(unit_weight_user_profile) <- colnames(feedback)
unit_weight_user_profile
```
### Calculating Predictions
The predictions for the Unit Weight are calculated as follows, by using the Cosine function on the question topic profile and the user profile created in the step above:

```{r}
unit_weight_predict_table <- data.frame()

for(i in 1:nrow(unit_weight_user_profile)){
  for(k in 1:nrow(question_topics)){
    unit_weight_predict_table[k,i]<- cosine(as.numeric(CB_unit_weight[k,]),as.numeric(unit_weight_user_profile[i,]))
  
  }
}
colnames(unit_weight_predict_table) <- rownames(simple_unary_user_profile)
unit_weight_predict_table[,"User.4"] <- 0
unit_weight_predict_table

```

### Likes tables 
Calculating likes, dislike and neutrals. When the prediction is bigger than 0 it is considered a like, when lower than 0, a dislike and when it is 0, it is considered to be neutral.
```{r}

likes_dislikes <- rbind(sapply(unit_weight_predict_table, function(x){sum(x>0)}))
likes_dislikes <- rbind(likes_dislikes,sapply(unit_weight_predict_table, function(x){sum(x<0)}))
likes_dislikes <- rbind(likes_dislikes,sapply(unit_weight_predict_table, function(x){sum(x==0)}))
rownames(likes_dislikes) <- c("likes", "dislikes","neutral")
likes_dislikes
```
## IDF
**With the unit weight applied, now evaluate the topics relevance using IDF. The higher the number of questions a topic has, the lower its relevance is. Rare topics would have more weight applying IDF now, thus being more relevant for the final prediction. With the new
predictions, provide the top-5 questions recommended per each user.** 

IDF recomendation engines are normalised by number of votes/rates present in an item and also all keywords are not considered equally significant.

### User Profile
To calculate the user profile it is first required to calculate the IDF which is equal to the log (#of questions / #questions with term (Df)). DF is equal to #questions with a value. Then we multiply the unit weight user profile calculated above, by the IDF.
```{r}
df <- sapply(question_topics,sum)
print(df)
idf <- log10(nrow(question_topics)/df)
print(idf)
idf_user_profile <- data.frame()


for(i in 1:nrow(unit_weight_user_profile)){
  idf_user_profile <- rbind(idf_user_profile,idf*unit_weight_user_profile[i,])
}
idf_user_profile
```


### Calculating Predictions
From the User Profile data calculated in section *Unit Weight* above, and the data about each question's topics, the predictions for the IDF are calculated as follows, by using the Cosine function:
```{r}
idf_predict_table <- data.frame()


for(i in 1:nrow(unit_weight_user_profile)){
  for(k in 1:nrow(question_topics)){
    idf_predict_table[k,i]<- cosine(as.numeric(question_topics[k,]),as.numeric(idf_user_profile[i,]))
  
  }
}
colnames(idf_predict_table) <- rownames(simple_unary_user_profile)
idf_predict_table[,"User.4"] <- 0
idf_predict_table

```

### Likes tables 
Count the total number of likes, dislikes and neutral predictions.
```{r}

likes_dislikes <- rbind(sapply(idf_predict_table, function(x){sum(x>0)}))
likes_dislikes <- rbind(likes_dislikes,sapply(idf_predict_table, function(x){sum(x<0)}))
likes_dislikes <- rbind(likes_dislikes,sapply(idf_predict_table, function(x){sum(x==0)}))
rownames(likes_dislikes) <- c("likes", "dislikes","neutral")
likes_dislikes
```

## Switched Hybrid
**The Assignment Question:
Consider the case of User4. User4 is new in the webpage and is not
having a defined profile. Solve the User4 cold-start problem switching the content-based to
non-personalise for users without actions collected. Provide the top-5 questions
recommended per each user.**

For each question, calculate the net sum of all of the answers given by the Users, giving answer_score. 
Then, standardise each of those values.
 
##Ignacio todo explain more about the change from the 0.2/0.4/0.4 weighting...

```{r}
answer_score <- apply(answers,1,function(x){sum(x, na.rm = T)})
answers$standardized_answers_score <- (answer_score-mean(answer_score))/sd(answer_score)
```

#### Calculate the mean of the three values for each question.
#### To come up with a final question score, apply a weighting to these results, split 90/10 between this mean and the standardized score.
#### Then, calculate the Top 5 Questions according to this code below:
```{r}
idf_average <- apply(idf_predict_table[,1:3],1, mean)
question_score <- 0.9*idf_average+0.1*answers$standardized_answers_score
questions_ratings <- cbind(question_score)
rownames(questions_ratings) <- rownames(question_topics)
sorted_top5<- as.data.frame(sort(questions_ratings[,1], decreasing = T)[1:5])
colnames(sorted_top5)<-"Top 5 Questions"
sorted_top5
```

```{r}
print("all question scores")
questions_ratings
```

## Hybrid Challenge

**The Assignment Question:
Define your own Quora-like RecSystem. Choose a feature-weighted 
linear stacking, a trust-aware CF, content-based similarity or build your own. It is key in this
exercise to explain in detail your solutions with good argumentations. The "best argumented"
solution will have the best note. Remember that a RecSystem is not just an algorithm. i.e.
A good way to show it is to use a mockup of the site, or app, that you envision, pointing out
the motivations and/or algorithm behind of each UI component (To collect implicit feedback,
to fill the profile explicitly, to recommend non-personalised questions to solve cold-start, etc.)
Solution for the Hybrid Challenge**

### Introduction to Quora
**Quora** is an American question-and-answer website where questions are asked, answered, and edited by users of the site or mobile app.
Currently, Quora has different ways to recommend questions to users: 

**Home feed question recommendations**
Quora provides "interesting" questions that are relevant to the User's preferences for topics that they have selected when they first sign up as a user to quora.

**Daily Digest**
Quora sends a daily email containing a set of questions with one answer that is deemed the best answer, given certain ranking criteria.

**Related Questions**
A set of questions that relates to the current question is displayed on the side. This display is not tailored to the specific user, it is based on the similarity to the current question.

**Requested Answers**
This feature lets a user direct a question to other users whom they consider better suited to answer it.


### Summary of Improvements to Quora's recommendations
To improve the recommendations given to users, we decided to introduce three new features.

####Feature 1 is called Magic Buttons.
This feature will provide the user with recommendations based on the User's current daily activity.  The criteria for the recommendations will be:
.	the time it will take to read the question and answer
.	the time of day 

####Feature 2 is called User Dynamic Topic Selection
This feature gives the user more opportunity to find new Topics that they might be interested in.  Currently, quora mobile app users can only search by typing in specific topics.  This new feature will give the user a List of Broad topics that they can browse through, select and then select subtopics.  

####Feature 3 is called Hot Topic Push 
For User with an interest in some broad topics such as Sport, this feature allows these Users to receive notifications about what are considered 'Hot Topics'.  These are Topics that are Hot in the sense that they are new, topical and often about an event that comes under the Parent topic of sport and can be about a SubTopic underneath the Sport Parent Topic. 
Examples of this would be a new Topic which is live during the two week duration of the Olympics, or long weekend of a Science and Technology Conference. 

### Feature 1 Magic Buttons
These buttons will appear in the app, on a left panel alongside the usual feed of questions.
The options that we will present and discuss here are as follows:

![](Capture1.PNG)

**Existing Users:**
For existing users such as Users 1 - 3 in the dataset we have been provided with, the Bathroom and Comute Questions are chosen from the ranked recommendations for the user which have already been identified using the Content Based IDF. 
For the Breakfast Question, the question is chosen from the currently Trending Topics across the overall application.
A Trending Topic is a topic that has had a high level of recent activity in terms of upvotes and answers. 

**Cold Start Users:**
For Cold Start users, such as User 4 in the dataset, as discussed above in the Switched Hybrid Solution, the most popular questions will be determined based on a combination of the average of the IDF predictions and the standardized answers score.

Let's walk through some mock-ups of how these Buttons will appear in the mobile app.  

For this assignment, we have renamed the app as 'Sharedge'; a portmanteau of Share and Knowledge.

**QandA_wordcount:** this represents the number of words in the Question plus Answer combined.  

![](Capture2.PNG)
![](Capture3.PNG)
![](Capture4.PNG)
![](Capture6.PNG)

Below is the logic that would be behind those mock up screens.

There is information in the dataset about whether the user has upvoted, downvoted, or answered the question. If the user didn't do any of this actions, we considered the user as not having read the question.  This is only assumed to create a recommendation system for current users.  Note also, we created a separate table in a file called (userfeedback.csv) that contains this information.

```{r}
read_table <- data.frame()
for(i in 1:ncol(feedback)){
  for(k in 1:nrow(feedback)){
  if(!is.na(feedback[k,i]) | !is.na(answers[k,i]) ){
    read_table[k,i] <- 1
  }
    else{
      read_table[k,i]<- 0
    }
  }
}
rownames(read_table) <- rownames(question_topics)
colnames(read_table) <- colnames(idf_predict_table)
read_table
```

For the sake of creating an app and adding more features, we created a random word count for each question. Moreover, we also created random dates for those questions, as an extra feature for our app. The date is used to calculate when the question was created.

```{r}
wordcount <- c(138,744,32,24,850,34,234,235,101,803,578,754,843,104,83,356,768,126,868,38)
x<-Sys.Date()
dates <- c(x-455,x-1,x-1,x-322,x-1,x-157,x-230,x-100,x-455, x-1, x-1, x-56, x-1,x,x-1, x-7,x-1,x-1,x-23, x-1)

wordcount_date <- data.frame(wordcount,dates)
colnames(wordcount_date) <- c("word count", "date posted")
rownames(wordcount_date) <- rownames(question_topics)
wordcount_date
```

In our app, we created a new Magic Button for bathroom reads. This Magic Button recommends questions for users where their predicted score is bigger than 0, the wordcount of each question is less than 150 (quick read) and to make sure that the user hasn't seen it before (based on previous assumption).
```{r}
bathroom_pred <- vector()
bathroom_pred_list <- data.frame("dummy" = c(1:20))
predict_table_all_users <- idf_predict_table
predict_table_all_users$User.4<- idf_average

for(i in 1:ncol(predict_table_all_users)){
  for(k in 1:nrow(read_table)){
    if(read_table[k,i]==0 & wordcount[k]<150 & predict_table_all_users[k,i]>0){
      bathroom_pred[k]=predict_table_all_users[k,i]
    }
    else{bathroom_pred[k]=0}
  }
  bathroom_pred_list <- cbind(bathroom_pred_list,bathroom_pred)

}
bathroom_pred_list$dummy <- NULL
colnames(bathroom_pred_list)<- colnames(predict_table_all_users)
rownames(bathroom_pred_list)<-rownames(question_topics)
bathroom_pred_list[!(apply(bathroom_pred_list,1,sum)==0),]
```
As well as the bathroom Magic Button, we created a commute Magic Button which recommends questions that usually take more time to read (> 700 words) and therefore makes the commute more entertaining.

```{r}
commute_pred <- vector()
commute_pred_list <- data.frame("dummy" = c(1:20))
predict_table_all_users <- idf_predict_table
predict_table_all_users$User.4<- idf_average


for(i in 1:ncol(predict_table_all_users)){
  for(k in 1:nrow(read_table)){
    if(read_table[k,i]==0 & wordcount[k]>700 & predict_table_all_users[k,i]>0){
      commute_pred[k]=predict_table_all_users[k,i]
    }
    else{commute_pred[k]=0}
  }
  commute_pred_list <- cbind(commute_pred_list,commute_pred)

}
commute_pred_list$dummy <- NULL
colnames(commute_pred_list)<- colnames(predict_table_all_users)
rownames(commute_pred_list)<-rownames(question_topics)
commute_pred_list[!(apply(commute_pred_list,1,sum)==0),]
```

and as for our last feature, we created a breakfast feature that includes trending topics from the last 48 hours, taking into considerstion the date column previously created.


```{r}

breakfast_pred <- vector()
breakfast_pred_list <- data.frame("dummy" = c(1:20))
predict_table_all_users <- idf_predict_table
predict_table_all_users$User.4<- idf_average


for(i in 1:ncol(predict_table_all_users)){
  for(k in 1:nrow(read_table)){
    if(read_table[k,i]==0 & dates[k]>(Sys.Date()-2) & predict_table_all_users[k,i]>0){
      breakfast_pred[k]=predict_table_all_users[k,i]
    }
    else{breakfast_pred[k]=0}
  }
  breakfast_pred_list <- cbind(breakfast_pred_list,breakfast_pred)

}
breakfast_pred_list$dummy <- NULL
colnames(breakfast_pred_list)<- colnames(predict_table_all_users)
rownames(breakfast_pred_list)<-rownames(question_topics)
breakfast_pred_list[!(apply(breakfast_pred_list,1,sum)==0),]

```
### Feature 2: User Dynamic Topic Selection
The screenshot below shows the Dynamic Topic Selection Option available to the User. In this screenshot you can see the the Main Topics such as Sports, Technology and Science.  Under sports you can see some SubTopics such as Tennis, Football, etc.   

![](Feature2_2.PNG)


### Feature 3: Hot Topic Push
The screenshot below shows the notification that the User will see.  The notification will be sent by the app because the User already follows a Sports Topic, and it is likely that they may also be interested in following a Trending Topic such as an international Sports tournament.


![](Feature2_1.PNG)


If the User responds Yes to Following the new Hot Topic, then the following Screen will be displayed:

![](Feature2_3.PNG)



